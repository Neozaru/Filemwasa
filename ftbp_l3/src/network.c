#include "network.h"int getMTU( SOCKET sock ) {	int mtu;	int mtulen = sizeof(mtu);	#ifdef WIN32		mtu = DEFAULT_FRAGMENT_SIZE;	#elif defined (linux)		// getsockopt( sock, SOL_IP, IP_MTU, &mtu, &mtulen ); // solution non-portable		mtu = DEFAULT_FRAGMENT_SIZE;	#endif			return mtu;}int send_readyMessage( SOCKET sock, int chunk ) {	nmessage readyMessage = { 0, chunk, "Ready" };	if ( send(sock, &readyMessage, sizeof(readyMessage) , 0) < 0 )  {		return -2;	}	return 0;}int recv_readyMessage( SOCKET sock  ) {		nmessage readyMessage = { 0 };	if ( recv(sock, &readyMessage, sizeof(readyMessage) , 0) < 0 )  {		printf("Receving error : ready message\n");		return -2;	}	else {		printf( "ACK for chunk %d (s%d)\n", readyMessage.arg2, sizeof(readyMessage) );	}				return readyMessage.arg2;}int send_transferRequest( SOCKET sock, int request_id, const char* file ) {	printf("Sending request for file %s\n", file);	nmessage fileInfosuest = { CMD_MESSAGE, request_id, "" };	strcpy( fileInfosuest.string, strdup(file) );	if ( send(sock, &fileInfosuest, sizeof(fileInfosuest) , 0) < 0 )  {		return -2;	}	return 0;}int send_nmessage ( SOCKET sock, nmessage* outputMessage ) {		if ( ( send(sock, outputMessage, sizeof(*outputMessage) , 0)) < 0 )  {						perror("send()");			#ifdef WIN32				printf("-%d-\n", WSAGetLastError());			#endif				exit(errno);			return -6;		}			return 0;}int recv_nmessage ( SOCKET sock, nmessage* incomingMessage ) {	if ( ( recv(sock, incomingMessage, sizeof(*incomingMessage) , 0)) < 0 )  {				perror("recv()");			#ifdef WIN32					printf("-%d-\n", WSAGetLastError());			#endif		return -6;	}		return 0;}/*********************************************************//*********************************************************//*********************************************************//*********************************************************//*********************************************************//*********************************************************/int send_file( SOCKET sock, const char* filePath ) {				printf("File confiuration : \n");				file_info fileInfos = new_fileInfosuest();		prepare_file_info( filePath, &fileInfos );		/* Ici on prepare le fichier en generant une politique de decoupage */		int dataCount;		print_file_info( &fileInfos ) ; // Debug				/* On envoi toutes les informations au Client */		if ( ( dataCount = send(sock, &fileInfos, sizeof(fileInfos) , 0)) < 0 )  {			printf("Send error : %d\n", dataCount);			return -2;		}		else {			printf("Datacount : %d/%d\n", dataCount,  sizeof(fileInfos) );		}				printf("Sending file ...\n");		/*********************		BEGIN TRANSFER		**********************/		int i = 0;		int flood_cpt = 0;		/* Reception des demandes du Client (quels blocs) */		nmessage readyMessage = { 0 };		if ( recv(sock, &readyMessage, sizeof(readyMessage) , 0) < 0 )  {			printf("Receving error : ready message\n");			return ERROR_RECV_ERROR;		}		else {			printf("ACK for chunk %d\n", readyMessage.arg2);						// On verifie quel bloc est demande. En principe on demarre au premier			if ( readyMessage.arg2 >= 0 && readyMessage.arg2 <= fileInfos.splitting_configuration.nb_chunks ) {				i = readyMessage.arg2;			}			else {				i = 0;			}		}		// Pour chaque Bloc		for ( ; i < fileInfos.splitting_configuration.nb_chunks; i++ ) {			// Si c'est le dernier bloc, sa taille ne sera pas la mÃªme.			int chunk_size;			if ( i + 1 == fileInfos.splitting_configuration.nb_chunks ) {				chunk_size = fileInfos.splitting_configuration.last_chunk_size;				printf("read Last chunk !\n");			}			else {				chunk_size = fileInfos.splitting_configuration.chunk_size;			}			printf("---------------\n| Chunk %d / %d |\n---------------\n", i+1, fileInfos.splitting_configuration.nb_chunks);			file_chunk fc = { 0 };						fc.id = i;						fragment_chunk( &fileInfos, &fc ); // On va lire un bloc dans le fichier											int j;			int sentData = 0;			// On envoie notre Bloc par lots de "DEFAULT_FRAGMENT_SIZE"			while ( sentData < chunk_size ) {								int sizeToSend;				if ( chunk_size - sentData < DEFAULT_FRAGMENT_SIZE ) {					sizeToSend = chunk_size - sentData;				}				else {					sizeToSend = DEFAULT_FRAGMENT_SIZE;				}				char* fragOut = (char*) malloc ( sizeToSend );				memcpy( fragOut, &fc.data[sentData], sizeToSend );								if ( ( dataCount = send(sock, fragOut, sizeToSend , 0)) < 0 )  {											printf("Sending error : %d at frag %d of chunk %d\n", dataCount, j+i, i+1);					perror("send()");					#ifdef WIN32						printf("-%d-\n", WSAGetLastError());					#endif					return ERROR_SEND_ERROR;				}				else {					sentData += dataCount;				}								free(fragOut);			}			free(fc.data);						printf("Chunk %d sent\n", i+1);								// S'il reste des blocs a envoyer			if ( i + 1 < fileInfos.splitting_configuration.nb_chunks ) {								int chunk_query = -1;				// On recupere le numero du Bloc demande par le Client				if ( ( chunk_query = recv_readyMessage( sock ) ) >= 0 ) {					// Dans le cas d'une reprise d'un telechargement precedent					if ( chunk_query <= fileInfos.splitting_configuration.nb_chunks ) {						// Si le bloc demande est le meme que le Bloc que celui qui vient d'etre envoye						if ( chunk_query == i ) {							flood_cpt++;						}						else {							flood_cpt = 0;						}												// Si le Client a demande + de X fois le meme Bloc, on abandonne.						if ( flood_cpt > MAX_BLOCK_FLOOD ) {							return ERROR_CHUNK_QUERY_FLOOD_DETECTED;						}						// "i" va etre incremente avec le "for".						// De toutes manieres, il ne pourra valoir moins de 0						i = chunk_query - 1;												// Si on arrive ici, on continue la boucle d'envois (seul cas de non-erreur)						// --> Oui, c'est une (trop) grosse fonction.					}					else {						return ERROR_BAD_CHUNK_QUERY;					}					}				else {					return ERROR_CHUNK_ACK;				}							}		}		/*********************		END TRANSFER		**********************/		// closesocket(sock);		return 0;}/* Update : La variable "already_downloaded_size" permet de commencer un telechargement	a un chunk X determine par la taille (already_downloaded_size) deja presente dans le disque, par exemple pour reprendre un transfert interrompu */int receive_file( SOCKET sock, const char* filePath, int already_downloaded_size ) {			printf("Begining reception ...\n");		file_info fileInfos = new_fileInfosuest();		if (  recv(sock,  &fileInfos, sizeof(fileInfos) , 0) < 0 )  {					printf("Reception error\n");			perror("recv()");			return ERROR_RECV_ERROR;					}					printf("fileInfos received\n");		int offset = 0;		int safe_chunks = 0;		// Si on a deja un morceau de fichier sur le disque		if ( already_downloaded_size > 0 ) {					if (  already_downloaded_size <= fileInfos.file_size ) {								/* Analyse la taille totale du fichier deja present et la compare 				   avec la taille des blocs definis pour en deduire le premier bloc				   a demander. On recule d'un Bloc, par securite.  */				   				offset = getChunkOffsetFromSize( already_downloaded_size, &(fileInfos.splitting_configuration) );				safe_chunks = 1;				debugpf("I will start download at chunk %d\n", offset+1);						}			else {							// Si la taille precedemment telechargee excede la taille totale attendue on considere que c'est un nouveau telech.				unlink( filePath );			}				}		strcpy( fileInfos.file, filePath );		printf("Print fileInfos : \n");		print_file_info( &fileInfos ) ;		/*********************		BEGIN TRANSFER		**********************/		int i=0;		i=0;			// To back home, drunk, and write an useless line : DONE.		for ( i = offset; i < fileInfos.splitting_configuration.nb_chunks; i++ ) {			if ( send_readyMessage( sock, i ) < 0 ) {				debugpf("Error while sending ready message for chunk %d", i+1);			}								int chunk_size;			if ( i + 1 == fileInfos.splitting_configuration.nb_chunks ) {				chunk_size = fileInfos.splitting_configuration.last_chunk_size;				printf("read Last chunk !\n");			}			else {				chunk_size = fileInfos.splitting_configuration.chunk_size;			}			printf("---------------\n| Chunk %d / %d |\n---------------\n", i+1, fileInfos.splitting_configuration.nb_chunks);			file_chunk fc = { 0 };			fc.data = (char*) malloc( chunk_size );			memset(fc.data, 0, chunk_size);			// On purge la zone memoire						int totalReceivedSize = 0;			// Tant qu'on a pas recu l'integralite du Bloc ...			while ( totalReceivedSize < chunk_size ) {								int dataCount;				char* fragIn = (char*) malloc( MAX_FRAGMENT_SIZE ) ; // FUITE								if ( ( dataCount = recv(sock, fragIn, MAX_FRAGMENT_SIZE, 0 )) < 0 )  {									printf("Reception error : %d / %d\n", dataCount, MAX_FRAGMENT_SIZE + 2 * 4 );					perror("recv()");					#ifdef WIN32						printf("-%d-\n", WSAGetLastError());					#endif										return ERROR_RECV_ERROR;				}				else {									memcpy( &fc.data[totalReceivedSize], fragIn, dataCount);					totalReceivedSize += dataCount;									}								free(fragIn);			}						fc.id = i;						if ( safe_chunks-- > 0 ) {				/* Permet d'ecrire "par dessus" une partie du fichier (option "w" au lieu de "a").					Utilise lorsqu'on reprend un telechargement precedemment interrompu					car certains bits peuvent "depasser" du fichier, et ne pas correspondre a la taille					actuelle des "chunk".					Dans tous les cas, ne sera utilise qu'une ou deux fois par telechargement.*/				assemble_chunk_safe( &fileInfos, &fc );				/* Apres cet appel, la taille du fichier est forcement un multiple de n chunks */			}			else {				/* Ecriture classique du Bloc dans notre fichier (on ajoute les donnees a la fin) */				assemble_chunk( &fileInfos, &fc );			}						free(fc.data);		}		/*********************		END TRANSFER		**********************/		printf("Checking md5 ...\n");		struct md5_ctx md5;				unsigned char digestCheck[16];				// Check MD5 entre la valeur recue avant le transfert et notre propre valeur		MDFile ( fileInfos.file, &md5, digestCheck ) ;				if ( memcmp( fileInfos.file_checksum, digestCheck, sizeof(fileInfos.file_checksum) ) == 0 ) {				}		else {			printf("Error : File corrupted\n"); // ... and good bye =)			return -3;		}			return 0;}int send_dirListing( SOCKET sock, char* path ) {	struct dirent* s_dir;	DIR* dir = NULL;	dir = opendir( path );		if ( dir != NULL ) {			int counter = 0;		while ( (s_dir = readdir( dir ) ) != NULL ) {			counter++;		}				if ( counter > 0 ) {					folder_listing_policy ls_config = { counter, 2, "" };						printf("Elements : %d\n", counter);						if ( send( sock, &ls_config, sizeof(ls_config), 0 ) != 0 ) {									}			else {				printf("Errer send\n");				return -1;			}						closedir( dir );			dir = opendir( path );						folder_elt* elementBuffer = (folder_elt*) malloc(0);						struct dirent* s_dir2;			int i=0;			int j=0;			while ( (s_dir2 = readdir( dir ) ) != NULL && j < ls_config.nb_total ) {							elementBuffer = (folder_elt*) realloc( elementBuffer, (i+1) * sizeof(folder_elt) );				memset( &elementBuffer[i], 0, sizeof(folder_elt) );							elementBuffer[i].infos = 0;								// Ici on va tester si notre element est un dossier				// Ne fonctionnera sans doute pas sous Windows				#ifdef WIN32				if ( isLocalDirectory( s_dir2->d_name ) ) {				#elif defined (linux)				if ( s_dir2->d_type == DT_DIR ) {				#else				if ( 0 ) {				#endif					/* On fait un "OU" sur le membre "info".						L'information "fichier ou dossier" tient						donc sur un seul bit (le premier de "info")					*/					elementBuffer[i].infos |= (1<8);					// Si c'est un dossier				}				strcpy( elementBuffer[i].pathname , s_dir2->d_name );				i++;				j++;								if ( i >= ls_config.nb_by_data || j >= ls_config.nb_total ) {										// printf("bf %s\n", s_dir2->d_name);					if ( send( sock, elementBuffer, sizeof(folder_elt)*i, 0 ) >= 0 ) {												printf("sent %d/%d (%s and ...)\n", j, ls_config.nb_total, elementBuffer[0].pathname);											}					else {						printf("Erreur send\n");												perror("send()");			#ifdef WIN32					printf("-%d-\n", WSAGetLastError());			#endif						return -1;					}									i=0;								}							}						closedir( dir );					}		else {			folder_listing_policy ls_config = { -1, -1, "" };									if ( send( sock, &ls_config, sizeof(ls_config), 0 ) != 0 ) {									}			else {				printf("Errer send\n");				return -1;			}					}			}		return 0;	}int recv_dirListing( SOCKET sock, char* path, dir_list** listing ) {	folder_listing_policy ls_config = { -1, -1, "" };		if ( recv( sock, &ls_config, sizeof(ls_config), 0 ) >= 0 ) {			}	else {		printf("Errer recv\n");		return -1;	}		if ( ls_config.nb_total != -1 ) {			if ( ls_config.nb_total == 0 ) {			(*listing)->nb_elements = 0;			return 0;		}			printf( "Nb elts : %d (by %d)\n", ls_config.nb_total, ls_config.nb_by_data);			int expectedBytes = ls_config.nb_total * sizeof(folder_elt);		(*listing)->elements = (folder_elt*) calloc( ls_config.nb_total, sizeof( folder_elt ) );		memset( (void*) ((*listing)->elements), 0, expectedBytes );		// Initialisation d'une liste d'elements				int i=0;		int j=0;		int byteCount=0;		int totalBytes=0;		do  {					i++;			j++;			printf("-");							char uBuffer[1024];				// Par defaut, on va recevoir les elements par groupes de 2				if ( (byteCount = recv( sock, &uBuffer[0], sizeof(folder_elt)*ls_config.nb_by_data, 0 )) >= 0 ) {						memcpy( (void*) ( (void*) ((*listing)->elements) + totalBytes), &uBuffer[0], byteCount );					totalBytes += byteCount;					printf("%d/%d --> %d/%d\n", byteCount, sizeof(folder_elt)*ls_config.nb_by_data, totalBytes, expectedBytes);					i=0;				}				else {					printf("Errer recv %d (sock %d)\n", byteCount, sock);							perror("recv()");			#ifdef WIN32					printf("-%d-\n", WSAGetLastError());			#endif									return -1;					}					} while ( totalBytes < expectedBytes );				(*listing)->nb_elements = totalBytes / sizeof(folder_elt);		return 0;			}	(*listing)->nb_elements = -1;		return 0;}