#ifndef H_NETWORK_H	#define H_NETWORK_H	#ifdef WIN32		#include <winsock2.h> /* Sockets pour Windows */		typedef int socklen_t;			#elif defined (linux)		#include <sys/socket.h>		#include <netdb.h>		/* Host by name */		#include <linux/types.h>		#include <sys/ioctl.h>		#include <net/if.h>		/* Sous Windows, "winsock2.h" definit certaines constantes qui ne sont pas definies par "socket.h" sous Linux */		#define INVALID_SOCKET -1		#define SOCKET_ERROR -1		/* Macro pour remplacer les 'closesocket' par 'close' sous Linux */		#define	closesocket(s) close(s)				/* Sous Windows, le type SOCKET (qui, en fait, est un 'int') est obligatoire.		On va donc definir le type SOCKET sous Linux comme etant un 'int', pour maximiser la portabilite du programme */		#ifndef SOCKET			typedef int SOCKET; 		#endif		/* Divergences egalement pour le nom des structures (casse) */		typedef struct sockaddr_in SOCKADDR_IN;		typedef struct sockaddr	SOCKADDR;		typedef struct in_addr IN_ADDR;	#endif		#include "file_ops.h"	#include "file_utils.h"	#include "protocol.h"	#include <string.h>	#include <unistd.h>				// typedef struct hostent hostent;	typedef struct nmessage_t {		int arg1;		int arg2;		char string[256];	} nmessage;		int recv_message( SOCKET sock, nmessage* incomingMessage );		int send_readyMessage( SOCKET sock, int chunk );	int recv_readyMessage( SOCKET sock  );		int send_transferRequest( SOCKET sock, int request_id, const char* file );		int send_nmessage ( SOCKET sock, nmessage* outputMessage );	int recv_nmessage ( SOCKET sock, nmessage* incomingMessage );		int send_dirListing( SOCKET sock, char* path );	int recv_dirListing( SOCKET sock, char* path, dir_list** listing );		int send_file( SOCKET sock, const char* filePath ) ;	int receive_file( SOCKET sock, const char* filePath, int already_downloaded_size ) ;	int getMTU( SOCKET sock );		#define TEST_PORT 2345	#define MAX_BLOCK_FLOOD 3	#define TIMEOUT_SEC 20	#endif